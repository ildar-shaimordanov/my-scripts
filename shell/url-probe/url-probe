#!/bin/bash

# =========================================================================
#
# Investigate URL
#
# Copyright (C) 2025 Ildar Shaimordanov
# MIT License
#
# =========================================================================

ME="${0##*/}"

print_probe_usage() {
	echo "\
Usage: $ME [-F PROBE_ENV] [-f PROBE_CODE] [-h] [-v] [-x] [-- [OPTIONS]]
Investigate URL.

Global options
	-F	Load variables from PROBE_ENV file
	-f	Load and run a probe from PROBE_CODE file
	-h	Show requests pretty formatted (headers and curl options)
	-v	Show raw request details (unparsed curl -v)
	-x	Print each shell command (same as set -x in shell)

If you need pass additional parameters to the probe, invent meanings for
OPTIONS, pass them and use their values or definitions while probing. A
double minus is mandatory because it separates global and custom options.
"
}

# +++
#
# # DESCRIPTION
#
# Investigate URL in easier way.
#
# # REQUIREMENTS
#
# * bash 4.3+
# * curl
# * awk
#
# ---

# =========================================================================

# +++
#
# # EQUIPMENT
#
# ---

# +++
#
# ## Functions for handling with URL
#
# ---

# +++
#
# ### `probe_url [OPTIONS]`
#
# Prepares and handle a request using curl.
#
# Under the hood collects all parameters in the following order: two
# options controlling verbosity, `PROBE_CURL_OPTS`, `PROBE_URL_HEADERS`
# and options passed by a user. This order ensures in major of cases that
# curl will send correct headers and data with a proper method. Otherwise,
# it's possible to fix some values in the known variables.
#
# Curl verbosity is kept in a temporary file. This provides possibility
# to print raw headers (with the `-v` option, the same as `curl -v` itself
# does) or print them in pretty formatted mode (with the `-h` option).
#
# Also a full command of curl invocation is printed with the `-h` option.
#
# ---

probe_url() (
	# Execute in subshell to simplify execution control

	local k v exit_code

	for k in "${!PROBE_URL_HEADERS[@]}"
	do
		v="${PROBE_URL_HEADERS[$k]}"
		set -- --header "$k: $v" "$@"
	done

	[ -t 0 ] \
	|| set -- --request POST --data @- "$@"

	set -- --silent --show-error --verbose "${PROBE_CURL_OPTS[@]}" "$@"

	# No immediate exit on error, to continue the rest of the function
	set +o errexit

	curl "$@" \
	2> >( eval "tee $PROBE_CURL_VERBOSE_FILE >$PROBE_CURL_VERBOSE_FD" )

	exit_code=$?

	[ $exit_code -ne 0 ] \
	&& grep "^curl: ($exit_code)" "$PROBE_CURL_VERBOSE_FILE" >&2

	[ -n "$PROBE_SHOW_IN_DETAILS" ] && (
		exec >&2

		echo "==== BEGIN DETAILS ===="
		echo "curl $*"
		array_pretty_print PROBE_URL_HEADERS
		probe_url_expose_headers
		array_pretty_print PROBE_URL_REQUEST_HEADERS
		array_pretty_print PROBE_URL_RESPONSE_HEADERS
		echo "==== END DETAILS ===="
	)

	return $exit_code
)

# +++
#
# ### `probe_url_print_cookie`
#
# Collects all `Set-Cookie` headers, join their values and prints as a
# single line. Internally it uses `probe_url_expose_headers`. However
# it is safe because the function is invoked in subshell and it doesn't
# affect on current values in the variables `PROBE_URL_*_HEADERS`.
#
# ---

probe_url_print_cookie() {
	awk 's { s = s " " } { s = s $1 } END { print s }' <<-!
	$(
		probe_url_expose_headers
		echo "${PROBE_URL_RESPONSE_HEADERS['Set-Cookie']}"
	)
	!
}

# +++
#
# ### `probe_url_expose_headers [print-only]`
#
# Reads a raw verbosity of the last curl invocation stored in a temporary
# file and populates `PROBE_URL_REQUEST_HEADERS` with sent headers and
# `PROBE_URL_RESPONSE_HEADERS` with received headers. This file is
# single so it keeps data of the latest curl invocation only. To not
# lost some data of previous reuests - better is to run this function
# between invocations and keep needed data.
#
# ---

probe_url_expose_headers() {
	[ "$1" != "print-only" ] && {
		eval "$( $FUNCNAME print-only )"
		return $?
	}

	awk \
	--assign apos="'" \
	--assign quot='"' \
	--assign bsol="\\" \
	--assign RS=$'\r?\n' '
	$0 !~ /^[<>] \S+:? / { next }

	$2 !~ /:$/ { sub(" ", " 0: ") }

	{
		# Make strings safe for executing in shell
		gsub(apos, apos bsol apos apos)

		sub(/:$/, "", $2)

		$3 = $0
		sub(/^\S+ \S+:? /, "", $3)

		s = headers[$1, $2]
		if ( s ) { s = s "\n" }
		s = s $3
		headers[$1, $2] = s
	}

	END {
		h[">"] = "PROBE_URL_REQUEST_HEADERS"
		h["<"] = "PROBE_URL_RESPONSE_HEADERS"

		for (p in h) {
			printf "declare -g -A %s=()\n", h[p]
		}

		for (p in headers) {
			split(p, r, SUBSEP)
			i = r[1]
			j = r[2]
			printf "%s[%s]=%s\n",
				h[i],
				apos j apos,
				apos headers[i, j] apos
		}
	}
	' "$PROBE_CURL_VERBOSE_FILE"
}

# =========================================================================

# +++
#
# ## Additional functions to simplify work with array variables
#
# ---

# +++
#
# ### `array_pretty_print ARRAY`
#
# Prints (associative) arrays pretty formatted. If some item is
# multi-lined, each substring is printed separately.
#
# ---

array_pretty_print() {
	declare -n name="${1?Source variable expected}"

	echo "$1:"

	printf '%s\n' "${!name[@]}" \
	| sort \
	| while read -r k
	do
		[ -n "$k" ] || continue

		v="${name[$k]}"
		[[ $v =~ $'\n' ]] \
		&& v=$'\n    '"${v//$'\n'/$'\n'    }"

		printf '  %s: %s\n' "$k" "$v"
	done
}

# +++
#
# ### `array_def ARRAY`
#
# Prints the variable definition. It's supposed that this function will
# ease in full copying one associative array variable to another one.
#
# Example:
#
# ```shell
# declare -A var1=([k1]=1 [k2]='2 3' [k3]=4)
# declare -A var2=$( array_def var1 )
# ```
#
# ---

array_def() {
	: "${1?Source variable expected}"

	local v="$( declare -p "$1" )"
	echo "${v#*=}"
}

# =========================================================================

# +++
#
# ## Additional functions for warnings and exiting
#
# ---

# +++
#
# ### `die [TEXT]`
#
# Prints to STDERR the text or `Died in LINE FUNC FILE` and exits with
# an error code = 1 or `$DIE` if specified.
#
# ---

die() {
	warn "${*:-Died in $( caller 0 )}"
	exit "${DIE:-1}"
}

# +++
#
# ### `warn [TEXT]`
#
# Prints to STDERR the text or `Warning in LINE FUNC FILE`.
#
# ---

warn() {
	echo "${*:-Warning in $( caller 0 )}" >&2
}

ctrace() {
	set -- 0 ; while caller $1 ; do set -- $(( $1+1 )) ; done
}

xtrace_off() {
	: "Turn xtrace off to avoid debug flooding"
	set +o xtrace
}

# =========================================================================

[ $# -gt 0 ] || {
	print_probe_usage
	exit
}

# Don't initialize variables PROBE_ENV and PROBE_CODE - let them be
# setup and exported from outer of the script.

PROBE_SHOW_IN_DETAILS=''
PROBE_CURL_VERBOSE_FD='/dev/null'
PROBE_SHELL_XTRACE=''

while getopts 'F:f:hvx' arg
do
	case "$arg" in
	F ) PROBE_ENV="$OPTARG" ;;
	f ) PROBE_CODE="$OPTARG" ;;
	h ) PROBE_SHOW_IN_DETAILS=1 ;;
	v ) PROBE_CURL_VERBOSE_FD='&2' ;;
	x ) PROBE_SHELL_XTRACE=1 ;;
	* ) die "Exit due to a parameter error" ;;
	esac
done

shift $(( OPTIND-1 ))

# =========================================================================

PROBE_CURL_VERBOSE_FILE="${TMP:-/tmp}/$ME-$$-curl-verbose"

trap 'probe_cleanup' EXIT

probe_cleanup() {
	rm "$PROBE_CURL_VERBOSE_FILE"
}

# =========================================================================

# Make execution stricter: exit immediately on any command error
set -o errexit

[ -n "$PROBE_SHELL_XTRACE" ] \
&& set -o xtrace

# =========================================================================

# +++
#
# ## Variables
#
# ---

# +++
#
# ### `PROBE_URL_HEADERS`
#
# The associative array keeps the user-defined headers that are supposed
# to be sent.
#
# ---

declare -A PROBE_URL_HEADERS=()

# +++
#
# ### `PROBE_URL_REQUEST_HEADERS`
#
# The associative array keeps the request headers of the last
# request. To actualize values with the most recent request invoke the
# `probe_url_expose_headers` function.
#
# ---

declare -A PROBE_URL_REQUEST_HEADERS=()

# +++
#
# ### `PROBE_URL_RESPONSE_HEADERS`
#
# The associative array keeps the response headers of the last
# request. To actualize values with the most recent request invoke the
# `probe_url_expose_headers` function.
#
# ---

declare -A PROBE_URL_RESPONSE_HEADERS=()

# +++
#
# ### `PROBE_CURL_OPTS`
#
# The list of additional options for curl.
#
# ---

declare -a PROBE_CURL_OPTS=()

# =========================================================================

# Load global settings
[ -f ~/."$ME" ] \
&& . ~/."$ME"

# Load custom settings (environment variables)
[ -n "$PROBE_ENV" ] \
&& . "$PROBE_ENV"

# Load custom code
[ -n "$PROBE_CODE" ] \
&& . "$PROBE_CODE"

# =========================================================================

# +++
#
# # SEE ALSO
#
# * Postman
# * Newman
# * HTTPie
#
# ---

# EOF
