# Как сэмулировать функцию `XLOOKUP`

Допустим, нам нужна таблица расходов и балансов, расписанных по банкам. Новые записи добавляются снизу хронологически, но по банкам - в произвольном порядке. Чтобы таблица заработала, надо для каждой новой записи расходов найти последнюю запись по банку, вычесть из него сумму и показать результат.

|    |A|B|C|D|
|--- |--- |--- |--- |--- |
|1   |дата 	|банк 	|сумма 	|баланс |
|2   |09.10.25 	|сбербанк 	| 	|2 000,00 ₽ |
|3   |09.10.25 	|альфабанк 	| 	|4 000,00 ₽ |
|4   |09.10.25 	|втб 	| 	|5 000,00 ₽ |
|5   |10.10.25 	|сбербанк 	|10,00 ₽ 	|1 990,00 ₽ |
|6   |11.10.25 	|сбербанк 	|900,00 ₽ 	|1 090,00 ₽ |
|7   |11.10.25 	|альфабанк 	|10,00 ₽ 	|3 990,00 ₽ |
|8   |11.10.25 	|сбербанк 	|25,00 ₽ 	|1 065,00 ₽ |
|9   |11.10.25 	|альфабанк 	|50,00 ₽ 	|3 940,00 ₽ |
|10  |14.10.25 	|втб 	|50,00 ₽ 	|4 950,00 ₽ |
|11  |14.10.25 	|сбербанк 	|100,00 ₽ 	|965,00 ₽ |
|12  |14.10.25 	|втб 	|100,00 ₽ 	|4 850,00 ₽ |
|13  |18.10.25 	|втб 	|100,00 ₽ 	|4 750,00 ₽ |

В Microsoft Excel и последних версиях LibreOffice есть замечательная функция `XLOOKUP`. Для нашего случая работает она так (например, для 13-ой строки таблицы):

```
=XLOOKUP(
	B13;
	$B$2:B12;
	$D$2:D12;
	;
	0;
	-1
)
```

Для значение из ячейки `B13` производится обратный поиск (`-1`) на точное соответствие (`0`) в диапазоне `$B$2:B12`. Для найденного значения в столбце `B` возвращается соответствующее значение из столбца `D`.

## Эмуляция

Если функция не поддерживается, а использовать ее хочется, то приходится эмулировать. Вот таблица, в которой собраны все формулы.

|    |A|B|C|D|E|F|G|
|--- |--- |--- |--- |--- |--- |--- |--- |
|1   |дата 	|банк 	|сумма 	|баланс 	|предыдущий баланс через xlookup 	|предыдущий баланс через эмуляцию 	|количество предыдущих записей |
|2   |09.10.25 	|сбербанк 	| 	|2 000,00 ₽ 	| 	| 	|0 |
|3   |09.10.25 	|альфабанк 	| 	|4 000,00 ₽ 	| 	| 	|1 |
|4   |09.10.25 	|втб 	| 	|5 000,00 ₽ 	| 	| 	|2 |
|5   |10.10.25 	|сбербанк 	|10,00 ₽ 	|1 990,00 ₽ 	|2 000,00 ₽ 	|2 000,00 ₽ 	|3 |
|6   |11.10.25 	|сбербанк 	|900,00 ₽ 	|1 090,00 ₽ 	|1 990,00 ₽ 	|1 990,00 ₽ 	|4 |
|7   |11.10.25 	|альфабанк 	|10,00 ₽ 	|3 990,00 ₽ 	|4 000,00 ₽ 	|4 000,00 ₽ 	|5 |
|8   |11.10.25 	|сбербанк 	|25,00 ₽ 	|1 065,00 ₽ 	|1 090,00 ₽ 	|1 090,00 ₽ 	|6 |
|9   |11.10.25 	|альфабанк 	|50,00 ₽ 	|3 940,00 ₽ 	|3 990,00 ₽ 	|3 990,00 ₽ 	|7 |
|10  |14.10.25 	|втб 	|50,00 ₽ 	|4 950,00 ₽ 	|5 000,00 ₽ 	|5 000,00 ₽ 	|8 |
|11  |14.10.25 	|сбербанк 	|100,00 ₽ 	|965,00 ₽ 	|1 065,00 ₽ 	|1 065,00 ₽ 	|9 |
|12  |14.10.25 	|втб 	|100,00 ₽ 	|4 850,00 ₽ 	|4 950,00 ₽ 	|4 950,00 ₽ 	|10 |
|13  |18.10.25 	|втб 	|100,00 ₽ 	|4 750,00 ₽ 	|4 850,00 ₽ 	|4 850,00 ₽ 	|11 |


Для этого потребуется вспомогательный столбец для подсчета количества предыдущих записей в таблице. Так как первая строка - это заголовок, то количество предыдущих записей будет равно `=ROW()-2`. Эта формула записана в ячейках столбца `G`. А в столбце `F` записана формула:

```
=INDEX(
	$D$2:D12;
	MATCH(
		MAXIFS(
			$G$2:G12;
			$B$2:B12;
			B13
		);
		$G$2:G12;
		0
	);
	1
)
```

Чтобы понять всю вакханалию, творящуюся здесь, надо начать читать изнутри.

Функция `MAXIFS` ищет все вхождения значения в ячейке `B13` (текущий банк) в диапазоне `$B$2:B12` (имена банков). Для каждого найденного значения выбираются значения из диапазона `$G$2:G12` (количества записей), для которых находится максимальное. В нашем случае это число `10`. 

Функция `MATCH` ищет это число в диапазоне `$G$2:G12` (получается уже повторный поиск) и возвращает его индекс.

Функция `INDEX`, используя результат предыдущей функции, из диапазона `$D$2:D12` (значения балансов) по индексу возвращает значение. В нашей задаче это предыдущий баланс для этого банка.

А в ячейках столбца `D` (начиная с ячейки `D5`) записана формула для подсчета баланса (на примере ячейки `D13`):

```
=F13-C13
```

## Дальнейшее развитие

Однако обходное решение не является решением на все 100%. Дело в том, что оригинальная `XLOOKUP` функция для пустых (несуществующих) значений в столбце `B` возвращает ошибку `#N/A`. В то же самое время наша конструкция возвращает значение баланса для первой строки данных (из ячейки `D2`), что не совсем корректно.

Поэтому дополним нашу формулу для ячеек столбца `F` следующим образом (для краткости показаны только дополнительные вычисления, остальное - это предыдущая формула):

```
=IF(
	ISBLANK(B13);
	1/0;
	INDEX...
)
```

Если ячейка - пустое значение (не содержит имени банка), генерируем ошибку. Иначе - вычисляем предыдущий баланс для текущего банка.

А в ячейках баланса (столбец `D`) введем формулу, которая будет отображать баланс только для правильных значений из столбца `F`:

```
=IF(
	ISERROR(F13);
	"";
	F13-C13
)
```

И теперь, растягивая формулы в ячеках `D-G` вниз, мы получим работающую таблицу.

### Еще чуть-чуть сходства

Предыдущее решение с выводом ошибки несколько отличается. Оригинальная функция в случае неуспеха возвращает ошибку `#N/A`. В нашем решении - `#DIV/0!`.

Если хочется иметь полностью аналогичный вывод с точностью до ошибки, вот другое решение:

```
=INDEX(
	$D$2:D12;
	MATCH(
		IF(
			ISBLANK(B13);
			G13;
			MAXIFS(
				$G$2:G12;
				$B$2:B12;
				B13
			)
		);
		$G$2:G12;
		0
	);
	1
)
```

Здесь главное отличие в том, что проверка на пустое значение "передвинуто" вглубь. Для случая, когда имя банка пустое значение (ячейка столбце `B`), в параметры функции подставляется текущее значение из ячейки столбца `G` (заведомо некорректное количество предыдущих записей, так как оно отсутствует в диапазоне `$G$2:G12`). А это приводит к последующей ошибке `#N/A`.

## Конечный результат

Сравнительная таблица всех рассмотренных способов.

|    |A|B|C|D|E|F|G|H|
|--- |--- |--- |--- |--- |--- |--- |--- |--- |
|1   |дата 	|банк 	|сумма 	|баланс 	|предыдущий баланс через xlookup 	|предыдущий баланс через эмуляцию с ошибкой #DIV/0! 	|предыдущий баланс через эмуляцию с ошибкой #N/A 	|количество предыдущих записей |
|2   |09.10.25 	|сбербанк 	| 	|2 000,00 ₽ 	| 	| 	| 	|0 |
|3   |09.10.25 	|альфабанк 	| 	|4 000,00 ₽ 	| 	| 	| 	|1 |
|4   |09.10.25 	|втб 	| 	|5 000,00 ₽ 	| 	| 	| 	|2 |
|5   |10.10.25 	|сбербанк 	|10,00 ₽ 	|1 990,00 ₽ 	|2 000,00 ₽ 	|2 000,00 ₽ 	|2 000,00 ₽ 	|3 |
|6   |11.10.25 	|сбербанк 	|900,00 ₽ 	|1 090,00 ₽ 	|1 990,00 ₽ 	|1 990,00 ₽ 	|1 990,00 ₽ 	|4 |
|7   |11.10.25 	|альфабанк 	|10,00 ₽ 	|3 990,00 ₽ 	|4 000,00 ₽ 	|4 000,00 ₽ 	|4 000,00 ₽ 	|5 |
|8   |11.10.25 	|сбербанк 	|25,00 ₽ 	|1 065,00 ₽ 	|1 090,00 ₽ 	|1 090,00 ₽ 	|1 090,00 ₽ 	|6 |
|9   |11.10.25 	|альфабанк 	|50,00 ₽ 	|3 940,00 ₽ 	|3 990,00 ₽ 	|3 990,00 ₽ 	|3 990,00 ₽ 	|7 |
|10  |14.10.25 	|втб 	|50,00 ₽ 	|4 950,00 ₽ 	|5 000,00 ₽ 	|5 000,00 ₽ 	|5 000,00 ₽ 	|8 |
|11  |14.10.25 	|сбербанк 	|100,00 ₽ 	|965,00 ₽ 	|1 065,00 ₽ 	|1 065,00 ₽ 	|1 065,00 ₽ 	|9 |
|12  |14.10.25 	|втб 	|100,00 ₽ 	|4 850,00 ₽ 	|4 950,00 ₽ 	|4 950,00 ₽ 	|4 950,00 ₽ 	|10 |
|13  |18.10.25 	|втб 	|100,00 ₽ 	|4 750,00 ₽ 	|4 850,00 ₽ 	|4 850,00 ₽ 	|4 850,00 ₽ 	|11 |
|14  | 	| 	| 	| 	|#N/A 	|#DIV/0! 	|#N/A 	|12 |
|15  | 	| 	| 	| 	|#N/A 	|#DIV/0! 	|#N/A 	|13 |

Здесь следующие формулы (для последней, 15-ой строки):

- столбец `D` (одна из трех)
```
=IF(ISERROR(E15);"";E15-C15)
=IF(ISERROR(F15);"";F15-C15)
=IF(ISERROR(G15);"";G15-C15)
````
- столбец `E`
```
=XLOOKUP(B15;$B$2:B14;$D$2:D14;;0;-1)
````
- столбец `F`
```
=IF(ISBLANK(B15);1/0;INDEX($D$2:D14;MATCH(MAXIFS($H$2:H14;$B$2:B14;B15);$H$2:H14;0);1))
````
- столбец `G`
```
=INDEX(D$2:$D14;MATCH(IF(ISBLANK(B15);H15;MAXIFS(H$2:$H14;B$2:$B14;B15));H$2:$H14;0);1)
````
- столбец `H`
```
=ROW()-2
````

Растягиваем формулы в `D-H` вниз и корректно заносим данные в `A-C`. Можно и нужно настроить проверки вводимых данных, прикрутить аналитику - и вот еще один ~~велосипед~~ домашний финансовый калькулятор готов.

Понятно, что надо решить какую формулу использовать в окончательном варианте, подкорректировать формулу в `D`, чтобы ссылаться на выбранный столбец, оставить один из столбцов `E-G`, а другие - удалить.

# Дополнение

В разделе _Еще чуть-чуть сходства_ я нагородил такой огород, что спустя время сам с трудом разобрался в написанном. Вариант с `#DIV/0!` гораздо приятнее и легче для восприятия, хотя, из-за потребности эмулировать, весьма сложен.

В предыдущем разделе _Дальнейшее развитие_ я использовал выражение `1/0`, чтобы сгенерировать ошибку вместо выполнения некорректных вычислений. Но вместо этого надо было использовать функцию `NA()`, которая успешно генерирует нужную ошибку.
